# 978最长湍流子数组

## 题目

> 当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：
>
> 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
> 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。
> 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。
>
> 返回 A 的最大湍流子数组的长度。
>
> 
>
> 示例 1：
>
> 输入：[9,4,2,10,7,8,8,1,9]
> 输出：5
> 解释：(A[1] > A[2] < A[3] > A[4] < A[5])
> 示例 2：
>
> 输入：[4,8,12,16]
> 输出：2
> 示例 3：
>
> 输入：[100]
> 输出：1
>
>
> 提示：
>
> 1 <= A.length <= 40000
> 0 <= A[i] <= 10^9
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/longest-turbulent-subarray
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##  解题思路

这个题目首先先弄清楚什么是湍流子数组？

> 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
> 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。
> 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

看完这个巴拉巴拉一段，说白了，就是剩下波动的一段，一高一低的折线图。感觉上这个题目应该是个==滑动窗口==的问题，通过 ==双指针==来模拟窗口的大小。继续考虑感觉也像个 `dp` 问题

<div align="center"> <img src="https://raw.githubusercontent.com/mambaJun/picture/master/blog/20210208165428.png"/> </div>

### 方法一：滑动窗口 （双指针 模拟窗口）

窗口 `[left, right](0 <= left <= right < n - 1)`中的范围，代表符合要求的「湍流子数组」，其中是跌宕起伏的，不能有等的情况。

1. 下面情况 right 都要右移动一个单位：
   1. arr[right - 1] < arr[right] 且 arr[right] > arr[right + 1]
   2. arr[right - 1] > arr[right] 且 arr[right] < arr[right + 1]
2. 不是 `1` 的情况那么就不符合「湍流子树组」，这时 left 右移动一位的也没有意义，直接将 left 移动到 right ，即 `left = right`
3. 不过需要注意一下当 `left = right` 的时候，此时没有什么比较价值，right 铁定右移动一位，那么我们只需要判断 `arr[right] = arr[right + 1]` 的存在，如果存在的话，需要将 left 和 right 同时右移动。

## 复杂度分析

时间复杂度：$\ O(n) $ ，[0, n -1] 遍历,执行了 n 次。

空间复杂度：$\ O(1) $

## 代码

```java
public int maxTurbulenceSize(int[] arr) {
    int n = arr.length;
    if (n == 1) return n;
    int left = 0, right = 0;
    int res = 0;

    while (right < n - 1) {
        // 移动
        if (left == right) {
            // 相等，left 和 right 同时 右移动
            if (arr[right] == arr[right + 1]) left++;
            right++;
        } else {
            // 符合规则
            if (arr[right - 1] > arr[right] && arr[right] < arr[right + 1]) right++;
            else if (arr[right - 1] < arr[right] && arr[right] > arr[right + 1]) right++;
            // 不符合规则，将窗口移动最右边，重置窗口
            else left = right;
        }
        res = Math.max(res, right - left + 1);
    }
    return res;
}
```





