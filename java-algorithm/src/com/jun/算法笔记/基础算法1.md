# 基础算法

## 一、[基础算法](https://www.acwing.com/blog/content/277/)

### 排序

### 二分

### 高精度

### 前缀和与差分

### 双指针算法

### 位运算

1. 查看 n 中的 第 k 位是 0 还是1 `n >> k & 1`

2. 获取 n 的最后一位 1 

   ```java
   // 获取 n 的最后一位 1
   n & -n
   - n = ~x + 1
   ```

3.    > 整数 n 的二进制表示中的第 K 位是 几？

      ```java
      public int hammingWeight(int n) {
          int count = 0;
          int k = 31;
          while (k -- >= 0) {
              count += n >>> k & 1;
          }
          return count;
      }
      ```

   [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

### 离散化

### 区间合并

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

## 二、数据结构

### 链表与邻接表：树与图的存储

### 栈与队列：单调队列、单调栈

### kmp

### Trie

### 并查集

#### 1、应用场景

1. 将两个集合合并
2. 查看两个元素是否在同一个集合中

#### 2、操作原理

每个集合用一个树来表示。树根的编号就是整个集合的编号，每个节点存储 它父节点

#### 3、常见的问题

> 假如用 p[x] 来表示 x 的父节点

1. 如何判断树根， 即 集合 的 编号

   ```java
   if (x == p[x]) // 是 树根
   ```

2. 如何求 x的集合 编号，也就是树根

   ```java
   int find (int x) {
       while (p[x] != x) x = p[x];
           return x;
   }
   // 优化 : 路径压缩  返回 根节点 + 路径压缩  
   int find(int x) {
        if(x == p[x]) return x;
   	return p[x] = find(p[x]);
   }
   ```

3. 如何合并两个集合？

   ```java
   // px 是 x 的集合编号，py 是集合y 的编号
   p[x] = y
   ```

   

#### 4、参考模板

```java
private int[] parent;
private int count;

// 初始化 集合 ，每个节点为一个集合
void init(int n) {
    count = n;
    parent = new int[n];

    for (int i = 0; i < n; i++) {
        parent[i] = i;
    }
}

// 获取当前节点的 根节点：返回 根节点 +  路径压缩
int find(int x) {
    if (x == parent[x]) return x;
    return parent[x] = find(parent[x]);
}

private int find(int x) {
    while (parent[x] != x) {
        // 进行路径压缩
        parent[x] = parent[parent[x]];
        x = parent[x];
    }
    return x;
}

// 合并两个集合
void union (int p, int q) {
    int pRoot = find(p);
    int qRoot = find(q);

    if (pRoot == qRoot) return;

    parent[pRoot]  = qRoot;
    
    count--;
}

// 两个节点是否 连通
boolean connected (int p, int q) {
    return find(p) == find(q);
}

// 集合个数
int count() {
    return count;
}
```

#### 5、题目推荐

[547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)

[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

### 堆

#### 自己手写堆

1. 向集合中插入一个数

   ```java
   heap[++size] = x;
   up(size);
   ```

2. 求集合中的最小值

   ```java
   heap[1];
   ```

   

3. 删除最小值

   ```java
   heap[1] = heap[size];
   size--;
   down(1);
   ```

   

4. 删除任意一个元素

   ```java
    heap(k) = heap[size];
   size--;
   down(k);
   up(k);
   ```

   

5. 修改任意一个元素

   ```java
   heap[k] = x;
   down(k);
   up(k); 
   
   ```

### Hash表

### C++ STL使用技巧

## 三、搜索与图论

### DFS与BFS

### 树与图的遍历：拓扑排序

### 最短路

#### 单源最短路

![](https://raw.githubusercontent.com/mambaJun/picture/master/blog/%E6%9C%80%E7%9F%AD%E8%B7%AF.png)

1. 所有边权 都是正数
   1. 朴素Dijkstra算法 O(n^2)
   2. 堆优化版Dijksta 算法 O(mlogn)
2. 存在负权边
   1. Bellman-Ford O(nm)
   2. SPFA  一般：O(m)  最坏：O(mn)

#### 多源最短路

Floyd 算法 O(n^3)

### 最小生成树

### 二分图：染色法、匈牙利算法

## 四、数学知识

质数
约数
欧拉函数
快速幂
扩展欧几里得算法
中国剩余定理
高斯消元
组合计数
容斥原理
简单博弈论

## 五、动态规划

背包问题
线性DP
区间DP
计数类DP
数位统计DP
状态压缩DP
树形DP
记忆化搜索

## 六、贪心

## 七、时空复杂度分析